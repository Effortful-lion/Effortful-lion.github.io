---
title: "内存优化"
weight: 1
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: true
# bookComments: false
# bookSearchExclude: false
# bookHref: ''
# bookIcon: ''
---

# 内存优化

🔹 核心理论层
- 三色标记法：Go GC 的核心算法，通过「黑、灰、白」三色标记对象的可达性，实现并发标记，减少 STW（Stop The World）时间。
- 混合写屏障（Hybrid Write Barrier）：Go 1.8 引入的优化，结合「插入写屏障」和「删除写屏障」的优势，在保证标记准确性的同时，进一步缩短 STW 时间。
- STW 触发时机：指 GC 过程中需要暂停所有 Goroutine 的阶段，主要发生在「初始标记」和「标记终止」两个阶段，优化目标是让 STW 时间控制在微秒级，避免游戏卡顿。

🔹 业务实践层（游戏场景优化）

1. 对象池（sync.Pool）的大量运用
- 游戏中存在大量高频创建 / 销毁的对象（如技能、子弹、玩家状态），用 sync.Pool 复用这些对象，避免频繁分配 / 回收触发 GC。
- 例如：子弹对象在发射后被回收，放回 sync.Pool，下次发射时直接从池里取，无需重新分配。
2. 减少逃逸分析
- 通过代码优化让对象尽量在栈上分配（而非堆上），栈上对象会随函数返回自动释放，不会进入 GC 扫描范围。
- 例如：将高频使用的小对象（如玩家坐标、技能参数）设计为值类型，避免指针逃逸到堆上。

```text
游戏服务对延迟极度敏感（如帧同步要求 16ms / 帧），GC 停顿哪怕是几毫秒都可能导致玩家感知卡顿，因此优化的核心是降低 GC 频率和单次 GC 耗时：

- 用 sync.Pool 复用对象：直接减少堆内存分配次数，从根源降低 GC 触发频率。
- 减少堆上对象数量：通过逃逸分析让更多对象在栈上分配，减少 GC 扫描的对象数量。
- 优先使用 noscan 类型：无指针的对象（如纯值类型）GC 时无需扫描，大幅减少 GC 耗时。
```