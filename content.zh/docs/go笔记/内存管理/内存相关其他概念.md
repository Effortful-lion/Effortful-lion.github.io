---
title: "内存相关其他概念"
weight: 1
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
# bookHref: ''
# bookIcon: ''
---

# 内存相关其他概念

## 内存对齐

简单的说，cpu一次性读取的数据位宽取决于cpu数据总线的个数。比如64位cpu，cpu总线个数为64。那么cpu一次性读取数据的位宽就是64位也就是8字节。

那么，当有一个变量是 8 字节，并且该变量在一个内存块上（cpu读取内存的单位是内存块），那么cpu只需要读取一次。但是如果该变量横跨两个内存块，那么cpu需要读取两次。

**内存对齐的情况：** 所有数据结构（包括 map、slice、channel 等）都会遵循内存对齐规则，区别仅在于「对齐的主体和方式」—— 基础类型 / 结构体是编译器自动对齐，复杂容器（map/slice）是运行时底层内存分配时强制对齐。

**内存对齐的作用：** 就是将一个变量所占用的内存放到一个内存块中。

**对齐值：** 基本数据类型的对齐值一般是数据类型本身。比如：int8=1、int32=4、int64=8、指针=8（64 位）

**结构体的对齐值：** 等于结构体字段中的最大对齐值。（所有属性向该属性对齐）
```go
// 游戏玩家坐标+血量（未优化字段顺序）
type BadPlayerData struct {
    X     int8  // 1字节，对齐值1 补7
    HP    int64 // 8字节，对齐值8
    Y     int8  // 1字节，对齐值1 补7
}
内存为：8 * 3 = 24

// 对齐后：
// 按「对齐值从大到小」排列字段
type BadPlayerData struct {
    HP    int64 // 8字节（0-7）
    X     int8  // 1字节（8）
    Y     int8  // 1字节（9）补6
    // 补6字节空洞（10-15），总大小16字节（8的倍数）
}
内存为：8 * 2 = 16
```

## 
